---
title: "Solving Nim (The Matchstick Game)"
excerpt_separator: "<!--more-->"
categories:
  - Project
tags:
  - Algorithms
  - Game Theory
---

A tough loss at a common grade-school pen and paper game while distracted in class led to me getting way more distracted in class, and spending the weekend writing an algorithm which could algorithmically determine the optimal move in games of Nim ([repository here](https://github.com/josh-holder/linegame)). This project was my first real foray into independent computer science passion projects.
{: .notice}

## Background/Rules of the Game
Recently, while getting off task in lecture, I came across a simple pen and paper game you might recognize from grade school (later, I realized the game was called [Nim](https://en.wikipedia.org/wiki/Nim)). In case you're not familiar, feel free to look up the rules or glance at my attempt at an explanation. The premise is simple - the game starts with a board like this:
{:refdef: style="text-align: center;"}
I I I I I
{: refdef}

{:refdef: style="text-align: center;"}
I I I
{: refdef}

{:refdef: style="text-align: center;"}
I
{: refdef}

The first player can cross out any amount of lines they want in a given row. For example, I might cross out two lines in the first row, leaving the following:

{:refdef: style="text-align: center;"}
I ~~I I~~ I I


{:refdef: style="text-align: center;"}
I I I


{:refdef: style="text-align: center;"}
I
{: refdef}

From here, the next player may cross out any amount of lines they want, provided they are in the same row and not separated by any strikethroughs already. The last player to strike through a line loses.

These would be valid board states arising after the second player moves:

{:refdef: style="text-align: center;"}
I ~~I I I~~ I
{: refdef}
{:refdef: style="text-align: center;"}
I I I
{: refdef}
{:refdef: style="text-align: center;"}
I
{: refdef}

{:refdef: style="text-align: center;"}
I ~~I I~~ I I
{: refdef}
{:refdef: style="text-align: center;"}
I ~~I~~ I
{: refdef}
{:refdef: style="text-align: center;"}
I
{: refdef}

But not this:

{:refdef: style="text-align: center;"}
~~I I I I~~ I

I I I

I
{: refdef}

Seems simple enough, right? Well, while half-playing against my friend and half-paying attention to the lecture, I kept losing the game. This bothered me; how was I getting bested so consistently at such a simple game? Furthermore, with no random elements, one thing was clear: at any given board, there was a winning sequence. This kept gnawing at me; what was the sequence, and how could I find it? 

An online search turned up no results so, as any overly competitive nerd would do, I spent most of the next weekend coding an algorithm designed to beat my classmate at a game designed for middle-schoolers.  

 
Transforming the puzzle into a palatable form for computers
In order to do any kind of calculations or simulations of the game, we need to figure out a way to define the state of a board in a format that the computer can understand. The first thing that comes to mind is that following board:

{:refdef: style="text-align: center;"}
I I I

I

I

{: refdef}

Is defined simply as a list with the entries 3, 1, and 1. However, given that both rows of 1 are functionally identical, I determined it to be easier to store board states in the form of a mapping (dictionary in python: read more here https://docs.python.org/3/tutorial/datastructures.html#dictionaries). 

In python dictionary terminology, the keys of the dictionary correspond to rows of that size, while the corresponding value of each key is the number of rows of that size. For example, the above board is defined as {3:1, 1:2}. This method is used to transcribe board states in all future algorithms. 

Generating all possible games given a board
The first thing that I wanted to do was to figure out a way to generate all the possible games that can be played from a given board state. I didn’t yet have a clear idea of how to leverage this information to determine the winner (and winning move) for a given board, but I had a gut feeling that it would help. It seemed to me that the best way to do so would be to utilize recursion. 
 

In simple terms, I envisioned that the program would take in an input board, say:

I I I
I

And then generate all the unique boards one could reach within one turn:

I I I
I

I I I
I

I I I
I

I I I
I

I I I
I

From there, the program would call itself on each of these new boards, and continue until reaching the board of 1 row, 1 line for all of the games. Along the way, the board at each step would be saved, eventually generating a list of lists of board states, or the complete collection of possible games that could arise from a given board.

After some tinkering (and some mostly uninteresting implementation work), I was able to create code that would perform this function, named LineGame_get_games.py on the github page.

Determining the winner of a given board state

With some of the groundwork laid with the function LineGame_get_games.py, it was time to actually have to figure out how to determine the winning sequence from a given board. Looking at all the possible games that could be played based on a given board configuration, one might imagine that it would be simple to figure out whether a board was a win or a loss. But when you get down to it, it’s tougher than you might expect to nail down the actual winner.  After some serious thought, I came up short with a “top down” approach to solving the problem, but I’m not a classically trained computer scientist, so I wouldn’t be surprised if one exists (if anyone has any ideas, be sure to let me know).

I decided to shift gears in my approach; instead of starting my search from the top at the initial board state, I decided to begin my search at the bottom of the tree instead. To do so required clearly defining what a forced win actually meant.

At the most basic level, a board is a win for one player if they can make a move and reduce the board to the state {1:1}. What boards can actually achieve this? When considering this, you find that the following boards can lead to this conclusion:

{2:1}, {3:1}, {4:1}, {5:1} …

{1:2}, {2:1, 1:1}, {3:1, 1:1}, {4:1, 1:1}, {5:1, 1:1} …

In general, a board can be reached from all boards which simply add lines to 

Note: python terminology
Algorithm:
•	Input: initial_board = game board in dictionary format
•	Initialize forced_losses and forced_wins, lists of board states which, when given to the agent, will always lead to a loss and a win respectively. Upon algorithm initialization, all we can say is that the board {1:1} is a forced loss.
•	Initialize new_forced_losses and new_forced_wins, lists of forced losses and wins that have yet to be expanded upon. Upon algorithm initialization, {1:1} is a “new forced loss”
•	add_factor = 0
•	while initial_board ¬has not been classified as a forced win or a forced loss:
o	if no new forced losses were found on the previous iteration, add_factor += 1
o	else: add_factor = 0
o	for loss in new_forced_losses:
	find all previous boards that could’ve led to the current forced loss, add them all to forced wins (you can just cross out the lines appropriately to reach the forced loss, and this means that these boards are forced wins)
	remove loss from new_forced_losses as it has now been expanded
	now you have some new forced wins
	for each new forced win:
•	find the previous games that could’ve led to them
•	for each previous game that could’ve led to the forced win, check all of the next moves. If they’re ALL in forced wins, then that is clearly a forced loss. Add this to the list and start over from the beginning

Todo: adding numbers to forced wins should also be from findPreviousMoves function
